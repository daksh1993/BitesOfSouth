import 'dart:io';
import 'dart:typed_data';
import 'package:bites_of_south/View/Analysis/pdf_viewer_screen.dart';
import 'package:flutter/material.dart';
import 'package:intl/intl.dart';
import 'package:pdf/pdf.dart';
import 'package:pdf/widgets.dart' as pw;
import 'package:path_provider/path_provider.dart'; // For saving PDF temporarily
import 'package:flutter/services.dart' show rootBundle;
import 'data_fetcher.dart';

// Generates a PDF report from analysis data
Future<Uint8List> generatePdf(Map<String, dynamic> data, DateTime? startDate,
    DateTime? endDate, List<String> selectedAnalyses) async {
  try {
    final pdf = pw.Document(); // Create a new PDF document
    final logoBytes = await fetchLogo(); // Fetch logo bytes
    final userData = await fetchUserData(); // Fetch user data
    final currencyFormat = NumberFormat.currency(
        locale: 'en_IN', symbol: 'â‚¹'); // Currency formatter
    final now = DateTime.now();
    final timestamp =
        DateFormat('dd/MM/yyyy HH:mm:ss').format(now); // Current timestamp

    print('PdfGenerator: Starting PDF generation - Data keys: ${data.keys}');

    // Load font for Rupee symbol support
    final fontData = await rootBundle.load('assets/fonts/NotoSans-Regular.ttf');
    final ttf = pw.Font.ttf(fontData);
    print('PdfGenerator: Font loaded successfully');

    final logoImage = logoBytes.isNotEmpty
        ? pw.MemoryImage(logoBytes)
        : null; // Logo image if available

    // Extract data maps with null safety
    final menuItems =
        data['menuItems'] as Map<String, Map<String, dynamic>>? ?? {};
    final itemQuantities = data['itemQuantities'] as Map<String, int>? ?? {};
    final itemRevenues = data['itemRevenues'] as Map<String, double>? ?? {};
    final itemProfits = data['itemProfits'] as Map<String, double>? ?? {};
    final trendingItems = data['trendingItems'] as Map<String, int>? ?? {};

    // Sort items for top/bottom analyses
    final sortedTrending = trendingItems.isNotEmpty
        ? (trendingItems.entries.toList()
          ..sort((a, b) => b.value.compareTo(a.value)))
        : <MapEntry<String, int>>[];
    final sortedProfits = itemProfits.isNotEmpty
        ? (itemProfits.entries.toList()
          ..sort((a, b) => b.value.compareTo(a.value)))
        : <MapEntry<String, double>>[];
    final sortedRevenues = itemRevenues.isNotEmpty
        ? (itemRevenues.entries.toList()
          ..sort((a, b) => b.value.compareTo(a.value)))
        : <MapEntry<String, double>>[];
    final sortedQuantities = itemQuantities.isNotEmpty
        ? (itemQuantities.entries.toList()
          ..sort((a, b) => b.value.compareTo(a.value)))
        : <MapEntry<String, int>>[];

    pdf.addPage(
      pw.MultiPage(
        header: (context) => pw.Container(
          alignment: pw.Alignment.center,
          margin: const pw.EdgeInsets.only(bottom: 20),
          child: pw.Column(
            children: [
              if (logoImage != null)
                pw.Image(logoImage,
                    width: 100, height: 100), // Logo if available
              pw.Text(
                'BitesOfSouth',
                style: pw.TextStyle(
                    fontSize: 24, fontWeight: pw.FontWeight.bold, font: ttf),
              ),
            ],
          ),
        ),
        footer: (context) => pw.Container(
          alignment: pw.Alignment.center,
          margin: const pw.EdgeInsets.only(top: 20),
          child: pw.Text(
            'Generated at: $timestamp',
            style: pw.TextStyle(fontSize: 12, font: ttf),
          ),
        ),
        build: (context) => [
          pw.Text(
            'Report generated by: ${userData['name']}',
            style: pw.TextStyle(
                fontSize: 16, fontWeight: pw.FontWeight.bold, font: ttf),
          ),
          pw.Text(
            'Role: ${userData['role']}',
            style: pw.TextStyle(fontSize: 14, font: ttf),
          ),
          pw.SizedBox(height: 20),
          pw.Text(
            'Analysis Report for ${startDate != null ? DateFormat('dd/MM/yyyy').format(startDate) : 'All Time'} - ${endDate != null ? DateFormat('dd/MM/yyyy').format(endDate) : 'Now'}',
            style: pw.TextStyle(fontSize: 16, font: ttf),
          ),
          pw.SizedBox(height: 20),
          if (selectedAnalyses.contains('Net Sales')) ...[
            pw.Text('Net Sales',
                style: pw.TextStyle(
                    fontSize: 18, fontWeight: pw.FontWeight.bold, font: ttf)),
            pw.Text('Total revenue generated from all sales.',
                style: pw.TextStyle(font: ttf)),
            pw.Text('Value: ${currencyFormat.format(data['netSales'] ?? 0.0)}',
                style: pw.TextStyle(font: ttf)),
            pw.SizedBox(height: 10),
          ],
          if (selectedAnalyses.contains('Net Profit')) ...[
            pw.Text('Net Profit',
                style: pw.TextStyle(
                    fontSize: 18, fontWeight: pw.FontWeight.bold, font: ttf)),
            pw.Text('Total profit after deducting making costs.',
                style: pw.TextStyle(font: ttf)),
            pw.Text('Value: ${currencyFormat.format(data['netProfit'] ?? 0.0)}',
                style: pw.TextStyle(font: ttf)),
            pw.SizedBox(height: 10),
          ],
          if (selectedAnalyses.contains('Top Selling Item')) ...[
            pw.Text('Top Selling Item',
                style: pw.TextStyle(
                    fontSize: 18, fontWeight: pw.FontWeight.bold, font: ttf)),
            pw.Text('Item with the highest quantity sold.',
                style: pw.TextStyle(font: ttf)),
            if (itemQuantities.isNotEmpty) ...[
              pw.Text(
                  'Item: ${menuItems[sortedQuantities.first.key]?['title'] ?? 'Unknown'}',
                  style: pw.TextStyle(font: ttf)),
              pw.Text('Quantity Sold: ${sortedQuantities.first.value}',
                  style: pw.TextStyle(font: ttf)),
              pw.Text(
                  'Revenue: ${currencyFormat.format(itemRevenues[sortedQuantities.first.key] ?? 0)}',
                  style: pw.TextStyle(font: ttf)),
              pw.Text(
                  'Profit: ${currencyFormat.format(itemProfits[sortedQuantities.first.key] ?? 0)}',
                  style: pw.TextStyle(font: ttf)),
            ] else ...[
              pw.Text('No data available.', style: pw.TextStyle(font: ttf)),
            ],
            pw.SizedBox(height: 10),
          ],
          if (selectedAnalyses.contains('Highest Revenue Item')) ...[
            pw.Text('Highest Revenue Item',
                style: pw.TextStyle(
                    fontSize: 18, fontWeight: pw.FontWeight.bold, font: ttf)),
            pw.Text('Item generating the highest revenue.',
                style: pw.TextStyle(font: ttf)),
            if (itemRevenues.isNotEmpty) ...[
              pw.Text(
                  'Item: ${menuItems[sortedRevenues.first.key]?['title'] ?? 'Unknown'}',
                  style: pw.TextStyle(font: ttf)),
              pw.Text(
                  'Revenue: ${currencyFormat.format(sortedRevenues.first.value)}',
                  style: pw.TextStyle(font: ttf)),
              pw.Text(
                  'Profit: ${currencyFormat.format(itemProfits[sortedRevenues.first.key] ?? 0)}',
                  style: pw.TextStyle(font: ttf)),
            ] else ...[
              pw.Text('No data available.', style: pw.TextStyle(font: ttf)),
            ],
            pw.SizedBox(height: 10),
          ],
          if (selectedAnalyses.contains('Least Selling Item')) ...[
            pw.Text('Least Selling Item',
                style: pw.TextStyle(
                    fontSize: 18, fontWeight: pw.FontWeight.bold, font: ttf)),
            pw.Text('Item with the lowest quantity sold.',
                style: pw.TextStyle(font: ttf)),
            if (itemQuantities.isNotEmpty) ...[
              pw.Text(
                  'Item: ${menuItems[sortedQuantities.last.key]?['title'] ?? 'Unknown'}',
                  style: pw.TextStyle(font: ttf)),
              pw.Text('Quantity Sold: ${sortedQuantities.last.value}',
                  style: pw.TextStyle(font: ttf)),
              pw.Text(
                  'Revenue: ${currencyFormat.format(itemRevenues[sortedQuantities.last.key] ?? 0)}',
                  style: pw.TextStyle(font: ttf)),
              pw.Text(
                  'Profit: ${currencyFormat.format(itemProfits[sortedQuantities.last.key] ?? 0)}',
                  style: pw.TextStyle(font: ttf)),
            ] else ...[
              pw.Text('No data available.', style: pw.TextStyle(font: ttf)),
            ],
            pw.SizedBox(height: 10),
          ],
          if (selectedAnalyses.contains('Lowest Revenue Item')) ...[
            pw.Text('Lowest Revenue Item',
                style: pw.TextStyle(
                    fontSize: 18, fontWeight: pw.FontWeight.bold, font: ttf)),
            pw.Text('Item generating the lowest revenue.',
                style: pw.TextStyle(font: ttf)),
            if (itemRevenues.isNotEmpty) ...[
              pw.Text(
                  'Item: ${menuItems[sortedRevenues.last.key]?['title'] ?? 'Unknown'}',
                  style: pw.TextStyle(font: ttf)),
              pw.Text(
                  'Revenue: ${currencyFormat.format(sortedRevenues.last.value)}',
                  style: pw.TextStyle(font: ttf)),
              pw.Text(
                  'Profit: ${currencyFormat.format(itemProfits[sortedRevenues.last.key] ?? 0)}',
                  style: pw.TextStyle(font: ttf)),
            ] else ...[
              pw.Text('No data available.', style: pw.TextStyle(font: ttf)),
            ],
            pw.SizedBox(height: 10),
          ],
          if (selectedAnalyses.contains('Trending Item')) ...[
            pw.Text('Trending Item',
                style: pw.TextStyle(
                    fontSize: 18, fontWeight: pw.FontWeight.bold, font: ttf)),
            pw.Text('Top trending item based on sales volume.',
                style: pw.TextStyle(font: ttf)),
            if (trendingItems.isNotEmpty) ...[
              pw.Text(
                  'Item: ${menuItems[sortedTrending.first.key]?['title'] ?? 'Unknown'}',
                  style: pw.TextStyle(font: ttf)),
              pw.Text('Quantity Sold: ${sortedTrending.first.value}',
                  style: pw.TextStyle(font: ttf)),
              pw.Text(
                  'Revenue: ${currencyFormat.format(itemRevenues[sortedTrending.first.key] ?? 0)}',
                  style: pw.TextStyle(font: ttf)),
              pw.Text(
                  'Profit: ${currencyFormat.format(itemProfits[sortedTrending.first.key] ?? 0)}',
                  style: pw.TextStyle(font: ttf)),
            ] else ...[
              pw.Text('No data available.', style: pw.TextStyle(font: ttf)),
            ],
            pw.SizedBox(height: 10),
          ],
          if (selectedAnalyses.contains('Total Items Sold')) ...[
            pw.Text('Total Items Sold',
                style: pw.TextStyle(
                    fontSize: 18, fontWeight: pw.FontWeight.bold, font: ttf)),
            pw.Text('Total number of items sold across all orders.',
                style: pw.TextStyle(font: ttf)),
            pw.Text('Value: ${itemQuantities.values.fold(0, (a, b) => a + b)}',
                style: pw.TextStyle(font: ttf)),
            pw.SizedBox(height: 10),
          ],
          if (selectedAnalyses.contains('Avg Revenue per Item')) ...[
            pw.Text('Average Revenue per Item',
                style: pw.TextStyle(
                    fontSize: 18, fontWeight: pw.FontWeight.bold, font: ttf)),
            pw.Text('Average revenue generated per unique item.',
                style: pw.TextStyle(font: ttf)),
            pw.Text(
                'Value: ${currencyFormat.format(itemRevenues.values.fold(0.0, (a, b) => a + b) / (itemRevenues.length > 0 ? itemRevenues.length : 1))}',
                style: pw.TextStyle(font: ttf)),
            pw.SizedBox(height: 10),
          ],
          if (selectedAnalyses.contains('Most Profitable Item')) ...[
            pw.Text('Most Profitable Item',
                style: pw.TextStyle(
                    fontSize: 18, fontWeight: pw.FontWeight.bold, font: ttf)),
            pw.Text('Item with the highest profit margin.',
                style: pw.TextStyle(font: ttf)),
            if (itemProfits.isNotEmpty) ...[
              pw.Text(
                  'Item: ${menuItems[sortedProfits.first.key]?['title'] ?? 'Unknown'}',
                  style: pw.TextStyle(font: ttf)),
              pw.Text(
                  'Profit: ${currencyFormat.format(sortedProfits.first.value)}',
                  style: pw.TextStyle(font: ttf)),
              pw.Text(
                  'Revenue: ${currencyFormat.format(itemRevenues[sortedProfits.first.key] ?? 0)}',
                  style: pw.TextStyle(font: ttf)),
            ] else ...[
              pw.Text('No data available.', style: pw.TextStyle(font: ttf)),
            ],
            pw.SizedBox(height: 10),
          ],
          if (selectedAnalyses.contains('Top 3 Items Revenue Share')) ...[
            pw.Text('Top 3 Items Revenue Share',
                style: pw.TextStyle(
                    fontSize: 18, fontWeight: pw.FontWeight.bold, font: ttf)),
            pw.Text('Revenue contribution of the top 3 items.',
                style: pw.TextStyle(font: ttf)),
            if (sortedRevenues.isNotEmpty) ...[
              pw.Text('Top 3 Items:', style: pw.TextStyle(font: ttf)),
              ...sortedRevenues.take(3).map((entry) => pw.Column(
                    crossAxisAlignment: pw.CrossAxisAlignment.start,
                    children: [
                      pw.Text(
                          '- ${menuItems[entry.key]?['title'] ?? 'Unknown'}: ${currencyFormat.format(entry.value)}',
                          style: pw.TextStyle(font: ttf)),
                      pw.Text(
                          '  Profit: ${currencyFormat.format(itemProfits[entry.key] ?? 0)}',
                          style: pw.TextStyle(font: ttf)),
                    ],
                  )),
              pw.Text(
                  'Total Revenue of Top 3: ${currencyFormat.format(sortedRevenues.take(3).fold(0.0, (sum, e) => sum + e.value))}',
                  style: pw.TextStyle(font: ttf)),
              pw.Text(
                  'Total Profit of Top 3: ${currencyFormat.format(sortedRevenues.take(3).fold(0.0, (sum, e) => sum + (itemProfits[e.key] ?? 0)))}',
                  style: pw.TextStyle(font: ttf)),
            ] else ...[
              pw.Text('No data available.', style: pw.TextStyle(font: ttf)),
            ],
            pw.SizedBox(height: 10),
          ],
        ],
        pageTheme: pw.PageTheme(
          pageFormat: PdfPageFormat.a4,
          buildBackground: (pw.Context context) {
            if (logoImage != null) {
              return pw.FullPage(
                ignoreMargins: true,
                child: pw.Opacity(opacity: 0.1, child: pw.Image(logoImage)),
              );
            }
            return pw.SizedBox();
          },
        ),
      ),
    );

    final pdfBytes = await pdf.save();
    print(
        'PdfGenerator: PDF generated successfully, bytes length: ${pdfBytes.length}');
    return pdfBytes;
  } catch (e) {
    print('PdfGenerator: Error generating PDF - $e');
    rethrow;
  }
}

// Saves the PDF to a temporary location and returns the file path
Future<String> savePdfToTemp(Uint8List pdfBytes) async {
  try {
    if (pdfBytes.isEmpty) {
      throw Exception('PDF bytes are empty');
    }
    print(
        'PdfGenerator: Saving PDF to temporary location, bytes length: ${pdfBytes.length}');

    // Get the temporary directory
    final tempDir = await getTemporaryDirectory();
    final fileName =
        'Analysis_Report_${DateFormat('yyyyMMdd_HHmmss').format(DateTime.now())}.pdf';
    final filePath = '${tempDir.path}/$fileName';

    final file = File(filePath);
    await file.writeAsBytes(pdfBytes); // Write the PDF bytes to the file

    print('PdfGenerator: PDF saved to temporary location - $filePath');
    return filePath;
  } catch (e) {
    print('PdfGenerator: Error saving PDF to temp - $e');
    rethrow;
  }
}

// Navigates to a new screen to display the PDF
void showPdfViewer(
    BuildContext context,
    Map<String, dynamic> data,
    DateTime? startDate,
    DateTime? endDate,
    List<String> selectedAnalyses) async {
  try {
    final pdfBytes =
        await generatePdf(data, startDate, endDate, selectedAnalyses);
    final pdfPath = await savePdfToTemp(pdfBytes); // Save PDF to temp location

    print('PdfGenerator: Navigating to PDF viewer screen with path: $pdfPath');

    // Navigate to the PDF viewer screen
    Navigator.push(
      context,
      MaterialPageRoute(
        builder: (context) => PDFViewerScreen(pdfPath: pdfPath),
      ),
    );
  } catch (e) {
    print('PdfGenerator: Error showing PDF viewer - $e');
    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(content: Text('Failed to display PDF: $e')),
    );
  }
}

// Explanation:
// This file handles PDF generation and navigation for the analysis dashboard. `generatePdf` creates a PDF document with a header, footer, and all selected analysis data (Net Sales, Net Profit, Top Selling Item, Highest Revenue Item, Least Selling Item, Lowest Revenue Item, Trending Item, Total Items Sold, Avg Revenue per Item, Most Profitable Item, Top 3 Items Revenue Share), using a custom font and optional logo. `savePdfToTemp` saves the PDF bytes to a temporary directory and returns the file path. `showPdfViewer` generates the PDF, saves it temporarily, and navigates to a new screen (PDFViewerScreen) to display it. Debugging statements track the process for troubleshooting.
